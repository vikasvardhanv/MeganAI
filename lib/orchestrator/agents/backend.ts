/**
 * Backend Agent - Enhanced Version
 * Uses Claude Sonnet for generating API routes and database schemas
 * Implements Zenflow's parallel execution pattern for faster generation
 */

import { ModelRouter } from "../../ai/router"
import type { Artifact } from "../core"
import type { ArchitectPlan, DataModelSpec } from "./architect"

export class BackendAgent {
    private router: ModelRouter

    constructor(apiKeys: Record<string, string>) {
        this.router = new ModelRouter(apiKeys)
    }

    async generateSchema(plan: ArchitectPlan): Promise<Artifact> {
        // Generate Prisma schema based on data models
        const schemaContent = this.buildPrismaSchema(plan)

        return {
            type: "code",
            path: "prisma/schema.prisma",
            content: schemaContent,
            language: "prisma"
        }
    }

    async generateAPIs(plan: ArchitectPlan): Promise<Artifact[]> {
        const artifacts: Artifact[] = []

        // Generate API routes for each data model (in parallel for speed)
        const apiPromises = plan.dataModels.map(async (model) => {
            return this.generateModelAPI(model, plan)
        })

        const modelAPIs = await Promise.all(apiPromises)
        artifacts.push(...modelAPIs)

        // Generate common API utilities
        artifacts.push(this.generateAPIUtils())
        artifacts.push(this.generateDatabaseClient())
        artifacts.push(this.generateAuthAPI(plan))

        return artifacts
    }

    private buildPrismaSchema(plan: ArchitectPlan): string {
        const models = plan.dataModels.map(model => this.buildModelSchema(model)).join('\n\n')

        return `// Prisma Schema for ${plan.appName}
// Generated by MeganAi Backend Agent

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

${models}

// ============ Session & Auth Models ============

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?  @db.Text
  access_token       String?  @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?  @db.Text
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
`
    }

    private buildModelSchema(model: DataModelSpec): string {
        const fields = model.fields.map(field => {
            const required = field.required ? '' : '?'
            const prismaType = this.mapToPrismaType(field.type)
            return `  ${field.name.padEnd(16)} ${prismaType}${required}${field.name === 'id' ? ' @id @default(cuid())' : ''}`
        }).join('\n')

        const timestamps = `
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt`

        // Add relations if model is User (connect to auth)
        const authRelations = model.name === 'User' ? `
  accounts         Account[]
  sessions         Session[]` : ''

        return `model ${model.name} {
${fields}${timestamps}${authRelations}

  @@map("${model.name.toLowerCase()}s")
}`
    }

    private mapToPrismaType(type: string): string {
        const typeMap: Record<string, string> = {
            'string': 'String',
            'String': 'String',
            'number': 'Int',
            'Number': 'Int',
            'int': 'Int',
            'Int': 'Int',
            'integer': 'Int',
            'float': 'Float',
            'Float': 'Float',
            'double': 'Float',
            'boolean': 'Boolean',
            'Boolean': 'Boolean',
            'bool': 'Boolean',
            'date': 'DateTime',
            'Date': 'DateTime',
            'DateTime': 'DateTime',
            'json': 'Json',
            'Json': 'Json',
            'object': 'Json'
        }
        return typeMap[type] || 'String'
    }

    private async generateModelAPI(model: DataModelSpec, plan: ArchitectPlan): Promise<Artifact> {
        const modelName = model.name
        const modelLower = modelName.toLowerCase()

        return {
            type: "code",
            path: `app/api/${modelLower}/route.ts`,
            content: `/**
 * ${modelName} API Routes
 * CRUD operations for ${modelName} model
 */

import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { db } from '@/lib/db'
import { z } from 'zod'

// Validation schema
const ${modelLower}Schema = z.object({
${model.fields
                    .filter(f => f.name !== 'id')
                    .map(f => `  ${f.name}: z.${this.getZodType(f.type)}()${f.required ? '' : '.optional()'}`)
                    .join(',\n')}
})

// GET - List all ${modelLower}s
export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession()
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const searchParams = req.nextUrl.searchParams
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '10')
    const skip = (page - 1) * limit

    const [items, total] = await Promise.all([
      db.${modelLower}.findMany({
        skip,
        take: limit,
        orderBy: { createdAt: 'desc' }
      }),
      db.${modelLower}.count()
    ])

    return NextResponse.json({
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    })
  } catch (error) {
    console.error('[${modelName} API] GET error:', error)
    return NextResponse.json(
      { error: 'Failed to fetch ${modelLower}s' },
      { status: 500 }
    )
  }
}

// POST - Create new ${modelLower}
export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession()
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await req.json()
    const validatedData = ${modelLower}Schema.parse(body)

    const ${modelLower} = await db.${modelLower}.create({
      data: validatedData
    })

    return NextResponse.json(${modelLower}, { status: 201 })
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      )
    }
    console.error('[${modelName} API] POST error:', error)
    return NextResponse.json(
      { error: 'Failed to create ${modelLower}' },
      { status: 500 }
    )
  }
}
`,
            language: "typescript"
        }
    }

    private getZodType(type: string): string {
        const typeMap: Record<string, string> = {
            'string': 'string',
            'String': 'string',
            'number': 'number',
            'Number': 'number',
            'int': 'number',
            'Int': 'number',
            'float': 'number',
            'Float': 'number',
            'boolean': 'boolean',
            'Boolean': 'boolean',
            'date': 'string', // Will be parsed as date
            'Date': 'string',
            'DateTime': 'string'
        }
        return typeMap[type] || 'string'
    }

    private generateAPIUtils(): Artifact {
        return {
            type: "code",
            path: "lib/api-utils.ts",
            content: `/**
 * API Utilities
 * Common helpers for API routes
 */

import { NextResponse } from 'next/server'
import { ZodError } from 'zod'

export class APIError extends Error {
  constructor(
    message: string,
    public statusCode: number = 500,
    public code?: string
  ) {
    super(message)
    this.name = 'APIError'
  }
}

export function handleAPIError(error: unknown) {
  console.error('[API Error]', error)

  if (error instanceof ZodError) {
    return NextResponse.json(
      { error: 'Validation failed', details: error.errors },
      { status: 400 }
    )
  }

  if (error instanceof APIError) {
    return NextResponse.json(
      { error: error.message, code: error.code },
      { status: error.statusCode }
    )
  }

  return NextResponse.json(
    { error: 'Internal server error' },
    { status: 500 }
  )
}

export function successResponse<T>(data: T, status: number = 200) {
  return NextResponse.json(data, { status })
}

export function paginatedResponse<T>(
  items: T[],
  page: number,
  limit: number,
  total: number
) {
  return NextResponse.json({
    items,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
      hasMore: page * limit < total
    }
  })
}
`,
            language: "typescript"
        }
    }

    private generateDatabaseClient(): Artifact {
        return {
            type: "code",
            path: "lib/db.ts",
            content: `/**
 * Database Client
 * Prisma client with connection pooling for production
 */

import { PrismaClient } from '@prisma/client'

declare global {
  var prisma: PrismaClient | undefined
}

export const db = globalThis.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development' 
    ? ['query', 'error', 'warn'] 
    : ['error']
})

if (process.env.NODE_ENV !== 'production') {
  globalThis.prisma = db
}

export default db
`,
            language: "typescript"
        }
    }

    private generateAuthAPI(plan: ArchitectPlan): Artifact {
        return {
            type: "code",
            path: "lib/auth.ts",
            content: `/**
 * Authentication Configuration
 * NextAuth.js setup for ${plan.appName}
 */

import { NextAuthOptions } from 'next-auth'
import { PrismaAdapter } from '@next-auth/prisma-adapter'
import CredentialsProvider from 'next-auth/providers/credentials'
import { db } from './db'

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(db),
  providers: [
    CredentialsProvider({
      name: 'credentials',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' }
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error('Email and password required')
        }

        const user = await db.user.findUnique({
          where: { email: credentials.email }
        })

        if (!user) {
          throw new Error('User not found')
        }

        // In production, verify password hash
        // const isValid = await bcrypt.compare(credentials.password, user.password)

        return {
          id: user.id,
          email: user.email,
          name: user.name
        }
      }
    })
  ],
  session: {
    strategy: 'jwt'
  },
  pages: {
    signIn: '/login',
    error: '/login'
  },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id
      }
      return token
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string
      }
      return session
    }
  }
}
`,
            language: "typescript"
        }
    }

    private toKebabCase(str: string): string {
        return str
            .replace(/([a-z])([A-Z])/g, '$1-$2')
            .toLowerCase()
    }

    private cleanCode(code: string): string {
        const codeBlockMatch = code.match(/```(?:prisma|typescript|ts)?\n([\s\S]*?)\n```/)
        if (codeBlockMatch) {
            return codeBlockMatch[1].trim()
        }
        return code.trim()
    }
}
